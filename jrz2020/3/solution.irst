没有参考解答, 只有之前回答别人类似的题时的解释. 其中大量手搓了 STL 算法, 而本题并没有限制 STL 算法的使用, **所以别看解答代码很多, 其实除了 replace 函数本身都是有现成的.**

对于函数 :cpp:`replace(主字符串 str, 子字符串 substr, 替换字符串 replace)`,

.. tabs::

  .. tab:: 通过临时空间进行

    :godbolt:`6jrxvY353`

    - 首先从 :cpp:`str` 中查找 :cpp:`substr` 子字符串, 返回子字符串在主字符串中第一个字符的下标.
    - 如果没找到, 那结束; 如果找到，继续以后步骤.
    - 创建一个临时数组 :cpp:`buffer`, 用于暂存结果.
    - 拷贝":cpp:`str` 的 :cpp:`substr` 子字符串之前的部分"到 :cpp:`buffer` 中.
    - 拷贝":cpp:`replace` 字符串"到 :cpp:`buffer` 中.
    - 拷贝":cpp:`str` 的 :cpp:`substr` 子字符串之后的部分"到 :cpp:`buffer` 中.
    - 将 :cpp:`buffer` 中内容拷贝回 :cpp:`str` 中.
    - 由于前后长度可能不同，需要在新的字符串末尾添加上 :cpp:`'\\0'` 表示这是字符串的结束.

  .. tab:: 原地进行

    :godbolt:`eWeGna1Pq`

    - 首先从 :cpp:`str` 中查找 :cpp:`substr` 子字符串，返回子字符串在主字符串中第一个字符的下标
    - 如果没找到，那结束；如果找到，继续以后步骤
    - 比较 :cpp:`substr` 和 :cpp:`replace` 的大小
        - 如果 :cpp:`replace` 更大，说明需要腾出更多空间，则子字符串后面的字符应该向右移动来腾出这些空间
        - 如果 :cpp:`substr` 更大，说明替换后这里会有多余的空间，则子字符串后面的字符应该向左移动，来填掉这些空间
    - 调整好空间后，将字符替换为 :cpp:`replace` 的字符
    - 由于前后长度可能不同，需要在新的字符串末尾添加上 :cpp:`'\\0'` 表示这是字符串的结束

.. warning::

  由于别人问的这个题函数为 :cpp:`replace(主字符串 str, 子字符串 substr, 替换字符串 replace)`, 参数非常糟糕, 所以替换字符串比原来的子字符串更长时, 替换结果并不正确, 但这是合理的——参数只提供了字符串本身的长度, 并没有给出整个字符数组所能使用的空间大小, 则实现不该假设字符数组所能使用的空间大于字符串当前长度.
